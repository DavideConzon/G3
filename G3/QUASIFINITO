import tkinter as tk
from tkinter import messagebox, ttk, filedialog
import csv
import hashlib
import cv2
import numpy as np
from PIL import Image, ImageTk
from tkinter import StringVar
import threading
import tensorflow as tf
import pandas as pd  

"""FUNZIONAMENTO DI ACQUISIZIONE E ANALISI DA FOTOCAMERA"""
# Global variables for camera and model
global result_label, cap, camera_thread, interpreter, camera_selection

result_label = None
cap = None
camera_thread = None
camera_selection = None  # Declare camera_selection globally
# Load the TFLite model
interpreter = tf.lite.Interpreter(model_path=r"C:\Users\david\OneDrive\Desktop\G3\skin_cancer_best_model.tflite")
interpreter.allocate_tensors()

#Percorso del new_users.csv
#NEW_CSV_FILE = model_path=r"C:\Users\david\OneDrive\Desktop\G3\new_users.csv

# Get tensor details
input_details = interpreter.get_input_details()
output_details = interpreter.get_output_details()

# Define model classes
class_labels = ['Actinic Keratoses and\n Intraepithelial Carcinoma', 'Basal Cell Carcinoma', 
                'Benign Keratosis-like Lesions', 'Dermatofibroma', 'Melanoma', 
                'Melanocytic Nevi (nei)', 'Vascular Lesions']

# Global variable for captured image
captured_image = None
captured_frame = None
camera_running = False

# Function to preprocess the image
def preprocess_image(image):
    image = Image.fromarray(image).convert("RGB")
    image = image.resize((224, 224))  # Size used for training
    image_array = np.array(image) / 255.0
    image_array = np.expand_dims(image_array, axis=0).astype(np.float32)  # Add batch dimension
    return image_array

# Function to classify and display results for loaded image
def classify_image():
    global captured_image
    image_path = filedialog.askopenfilename()
    if image_path:
        # Preprocess the image
        image = Image.open(image_path).convert("RGB")
        image_array = preprocess_image(np.array(image))
        
        # Set input tensor for interpreter
        interpreter.set_tensor(input_details[0]['index'], image_array)
        interpreter.invoke()
        predictions = interpreter.get_tensor(output_details[0]['index'])[0]
        
        # Display image
        img = image.resize((500, 500))
        img_tk = ImageTk.PhotoImage(img)
        canvas.itemconfig(image_container, image=img_tk)
        canvas.image = img_tk  # Avoid image garbage collection
        captured_image = img_tk
        
        # Show results
        result_text = "Classification:\n"
        for label, prob in zip(class_labels, predictions):
            result_text += f"{label}: {prob * 100:.2f}%\n"
        
        result_label.config(text=result_text)
        
        # Save results to CSV
        results_df = pd.DataFrame({'Class': class_labels, 'Probability': predictions * 100})
        results_df.to_csv('classification_results.csv', index=False)

# Function to classify and display results for each frame
def classify_frame(frame):
    image_array = preprocess_image(frame)
    interpreter.set_tensor(input_details[0]['index'], image_array)
    interpreter.invoke()
    predictions = interpreter.get_tensor(output_details[0]['index'])[0]
    
    result_text = "Classification:\n"
    for label, prob in zip(class_labels, predictions):
        result_text += f"{label}: {prob * 100:.2f}%\n"
    
    result_label.config(text=result_text)

# Function to capture an image from the camera
def capture_image():
    global captured_image, captured_frame, camera_running
    camera_running = False  # Stop camera feed
    selected_camera = int(camera_selection.get())  # Use the global camera_selection
    cap = cv2.VideoCapture(selected_camera)
    ret, frame = cap.read()
    if ret:
        captured_frame = frame  # Store captured frame
        cv2.imwrite("captured_image.jpg", frame)
        print("Captured image saved as 'captured_image.jpg'")
        # Show captured image
        frame_rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
        img = Image.fromarray(frame_rgb)
        img = img.resize((500, 500))
        img_tk = ImageTk.PhotoImage(img)
        canvas.itemconfig(image_container, image=img_tk)
        canvas.image = img_tk
        captured_image = img_tk
    cap.release()

# Declare canvas and image_container globally
canvas = None
image_container = None

# Function to start the camera feed
def start_camera():
    global captured_image, captured_frame, camera_running, canvas, image_container
    camera_running = True  # Set camera state
    selected_camera = int(camera_selection.get())  # Use the global camera_selection
    captured_image = None  # Reset captured image
    captured_frame = None  # Reset captured frame
    cap = cv2.VideoCapture(selected_camera)
    
    def update_frame():
        global canvas, image_container
        if camera_running and cap.isOpened():
            ret, frame = cap.read()
            if ret:
                # Resize and display frame in Tkinter if no image is captured
                if captured_image is None:
                    frame_rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
                    img = Image.fromarray(frame_rgb)
                    img = img.resize((500, 500))
                    img_tk = ImageTk.PhotoImage(img)
                    canvas.itemconfig(image_container, image=img_tk)
                    canvas.image = img_tk
                    
                    # Classify frame
                    classify_frame(frame_rgb)
            
            root.after(10, update_frame)  # Update frame every 10 ms
        else:
            cap.release()

    update_frame()  # Start frame update

def show_camera_screen(user_name, user_role):
    global canvas, image_container
    for widget in root.winfo_children():
        widget.destroy()

    camera_frame = tk.Frame(root, bg='#f0f0f0', padx=20, pady=20)
    camera_frame.pack(fill=tk.BOTH, expand=True)

    tk.Label(camera_frame, text=f"Welcome {user_name}, Role: {user_role}", font=("Arial", 16), bg='#f0f0f0', fg="#333").pack(pady=20)

    # Add Back Button
    back_button = ttk.Button(camera_frame, text="Back", command=show_welcome_screen)  # Adjust to show_login_screen if needed
    back_button.pack(pady=10)

    global camera_selection
    # Camera selection dropdown
    camera_selection = StringVar(value="0")
    camera_dropdown_label = tk.Label(camera_frame, text="Select Camera:", bg="#ffffff", font=("Arial", 12))
    camera_dropdown_label.pack(pady=5)

    camera_dropdown = ttk.Combobox(camera_frame, textvariable=camera_selection, values=["0", "1", "2"], state="readonly")
    camera_dropdown.pack(pady=10)

    # Buttons for camera actions
    btn_camera = ttk.Button(camera_frame, text="Start Camera", command=start_camera)
    btn_camera.pack(pady=10)

    btn_load_image = ttk.Button(camera_frame, text="Load Image", command=classify_image)
    btn_load_image.pack(pady=10)

    btn_capture_image = ttk.Button(camera_frame, text="Capture Image", command=capture_image)
    btn_capture_image.pack(pady=10)

    stop_camera_button = ttk.Button(camera_frame, text="Stop Camera", command=stop_camera)
    stop_camera_button.pack(pady=10)

    global result_label
    result_label = ttk.Label(camera_frame, text="Classification:", justify="left", background="#ffffff", anchor="n", font=("Arial", 12, "bold"))
    result_label.pack(pady=20, padx=10, fill="both", expand=True)

    # Create a canvas for displaying the image
    canvas = tk.Canvas(camera_frame, width=500, height=500)
    canvas.pack(pady=20)
    image_container = canvas.create_image(250, 250, anchor=tk.CENTER)

# Function to stop the camera
def stop_camera():
    global camera_running
    camera_running = False


"""FUNZIONALITA' DI LOGIN/REGISTER"""
# Show welcome screen as the first screen



# Patient class
class Paziente:
    def __init__(self, nome, cognome, data_nascita, sesso, codice_fiscale, indirizzo, telefono, email, patologie_precedenti, farmaci_assunti):
        self.nome = nome
        self.cognome = cognome
        self.data_nascita = data_nascita
        self.sesso = sesso
        self.codice_fiscale = codice_fiscale
        self.indirizzo = indirizzo
        self.telefono = telefono
        self.email = email
        self.patologie_precedenti = patologie_precedenti
        self.farmaci_assunti = farmaci_assunti

    def visualizza_anagrafica(self):
        return f"Nome: {self.nome} {self.cognome}\nEmail: {self.email}\nTelefono: {self.telefono}"
    
# Funzione per hash della password
def hash_password(password):
    # Genera l'hash della password utilizzando SHA-256
    return hashlib.sha256(password.encode('utf-8')).hexdigest()

# Funzione per la registrazione utente
def register_user(name, role, email, password):
    # Controlla che tutti i campi siano compilati
    if not all([name, role, email, password]):
        messagebox.showerror("Errore", "Tutti i campi sono obbligatori!")
        return

    # Esegue il salvataggio sicuro della password
    hashed_password = hash_password(password)

    # Salva i dati nel file CSV
    try:
        with open('users.csv', 'a', newline='') as file:
            writer = csv.writer(file)
            writer.writerow([name, role, email, hashed_password])
        messagebox.showinfo("Registrazione", "Registrazione completata con successo!")
    except Exception as e:
        messagebox.showerror("Errore", f"Errore durante la registrazione: {e}")

# Function to show the login screen
def show_login_screen():
    login_frame = tk.Frame()
    login_frame.pack(fill=tk.BOTH, expand=True)

    tk.Label(login_frame, text="Login", font=("Arial", 16), bg='#f0f0f0', fg="#333").pack(pady=20)

    tk.Label(login_frame, text="Email:", bg="#ffffff", font=("Arial", 12)).pack(pady=5)
    email_entry = tk.Entry(login_frame, font=("Arial", 12))
    email_entry.pack(pady=5)

    tk.Label(login_frame, text="Password:", bg="#ffffff", font=("Arial", 12)).pack(pady=5)
    password_entry = tk.Entry(login_frame, font=("Arial", 12), show="*")
    password_entry.pack(pady=5)

    login_button = ttk.Button(login_frame, text="Login", command=lambda: login_callback(email_entry, password_entry))
    login_button.pack(pady=20)

    register_button = ttk.Button(login_frame, text="Register", command=show_registration_screen)
    register_button.pack(pady=10)

# Function to hash the password
def hash_password(password):
    return hashlib.sha256(password.encode('utf-8')).hexdigest()

# Function to login user
def login_user(email, password):
    try:
        with open('users.csv', 'r') as file:
            for row in csv.reader(file):
                if row[3] == email:  # Check if the email exists
                    # Extract the stored hashed password
                    stored_hashed_password = row[5]
                    
                    # Hash the entered password and compare with the stored hashed password
                    if hash_password(password) == stored_hashed_password:
                        # If the passwords match, proceed with login
                        messagebox.showinfo("Successo", "Login effettuato con successo!")
                        show_patient_screen(row[0])  # Assuming the first column is the user's name
                        return
                    else:
                        # If the passwords do not match
                        messagebox.showerror("Errore", "Password errata!")
                        return
            
            # If no matching email is found
            messagebox.showerror("Errore", "Email non registrata!")
    except FileNotFoundError:
        messagebox.showerror("Errore", "Il file CSV non esiste!")
    except Exception as e:
        messagebox.showerror("Errore", f"Errore durante il login: {e}")

# Login callback function
def login_callback(email_entry, password_entry):
    email = email_entry.get()
    password = password_entry.get()

    if not email or not password:
        messagebox.showerror("Error", "Email and Password are required!")
        return

    hashed_password = hash_password(password)
    
    with open('users.csv', 'r') as file:
        reader = csv.reader(file)
        for row in reader:
            if row[2] == email and row[3] == hashed_password:
                user_role = row[1]
                user_name = row[0]
                show_camera_screen(user_name, user_role)  # Switch to the camera screen
                return
    messagebox.showerror("Error", "Invalid credentials!")

def show_patient_screen(name):
    clear_frame()
    tk.Label(root, text=f"Ciao {name}", font=("Arial", 16)).pack(pady=20)

# Function to show the registration screen
def show_registration_screen():
    for widget in root.winfo_children():
        widget.destroy()

    # Frame di registrazione
    register_frame = tk.Frame(root, bg='#f0f0f0', padx=20, pady=20)
    register_frame.pack(fill=tk.BOTH, expand=True)

    tk.Label(register_frame, text="Registrazione", font=("Arial", 16), bg='#f0f0f0', fg="#333").pack(pady=20)

    # Campo Nome
    tk.Label(register_frame, text="Nome:", bg="#ffffff", font=("Arial", 12)).pack(pady=5)
    name_entry = tk.Entry(register_frame, font=("Arial", 12))
    name_entry.pack(pady=5)

    # Campo Ruolo (con dropdown)
    tk.Label(register_frame, text="Ruolo:", bg="#ffffff", font=("Arial", 12)).pack(pady=5)
    role_var = tk.StringVar(register_frame)
    role_var.set("Seleziona un ruolo")  # Valore predefinito
    roles = ["Admin", "Medico", "User", "Guest"]
    role_menu = tk.OptionMenu(register_frame, role_var, *roles)
    role_menu.config(font=("Arial", 12), bg="#ffffff", fg="#333")
    role_menu.pack(pady=5)

    # Campo Email
    tk.Label(register_frame, text="Email:", bg="#ffffff", font=("Arial", 12)).pack(pady=5)
    email_entry = tk.Entry(register_frame, font=("Arial", 12))
    email_entry.pack(pady=5)

    # Campo Password
    tk.Label(register_frame, text="Password:", bg="#ffffff", font=("Arial", 12)).pack(pady=5)
    password_entry = tk.Entry(register_frame, font=("Arial", 12), show="*")
    password_entry.pack(pady=5)

    # Azione registrazione
    def register_action():
        name = name_entry.get()
        role = role_var.get()
        email = email_entry.get()
        password = password_entry.get()
        if name and role != "Seleziona un ruolo" and email and password:
            register_user(name, role, email, password)
        else:
            messagebox.showerror("Errore", "Tutti i campi sono obbligatori!")

    # Pulsante di registrazione
    register_button = ttk.Button(register_frame, text="Registrati", command=register_action)
    register_button.pack(pady=20)

# Welcome screen function
def show_welcome_screen():
    global camera_label
    # Stop the camera if it is running
    stop_camera()
    camera_label = None

    # Destroy the existing screen and load the welcome screen
    for widget in root.winfo_children():
        widget.destroy()

    # Main container frame
    welcome_frame = tk.Frame(root, bg="#f7f9fc")
    welcome_frame.pack(fill=tk.BOTH, expand=True)

    # Welcome message
    tk.Label(welcome_frame, text="Benvenuto nel Sistema di Gestione Pazienti",
             font=("Arial", 20, "bold"), bg="#f7f9fc", fg="#333").pack(pady=30)

    # Add a logo or image placeholder
    try:
        logo_image = Image.open("logo.png")  # Replace with your logo path
        logo_image = logo_image.resize((150, 150))  # Resize as needed
        logo_photo = ImageTk.PhotoImage(logo_image)
        tk.Label(welcome_frame, image=logo_photo, bg="#f7f9fc").pack()
        welcome_frame.logo_image = logo_photo  # Avoid garbage collection
    except Exception as e:
        print(f"Could not load logo: {e}")

    # Buttons for Login and Registration
    button_style = {"font": ("Arial", 14, "bold"), "bg": "#4CAF50", "fg": "white", "activebackground": "#45a049"}
    tk.Button(welcome_frame, text="Accedi", command=show_login_screen, **button_style, width=15).pack(pady=20)
    tk.Button(welcome_frame, text="Registrati", command=show_registration_screen, **button_style, width=15).pack(pady=10)

    # Footer text
    tk.Label(welcome_frame, text="Gestione completa per pazienti e analisi mediche",
             font=("Arial", 10, "italic"), bg="#f7f9fc", fg="#666").pack(pady=30)

def show_role_screen(name, role):
    clear_frame()
    tk.Label(root, text=f"Ciao {name}, Ruolo: {role}", font=("Arial", 16)).pack(pady=20)
    tk.Button(root, text="Avvia Fotocamera", command=start_camera).pack(pady=10)
    tk.Button(root, text="Ferma Fotocamera", command=stop_camera).pack(pady=10)

def create_back_button(parent, back_command):
    back_button = tk.Button(parent, text="Back", command=back_command)
    back_button.pack(pady=10)
    return back_button

# Main function to run the application
def main():
    global root
    root = tk.Tk()
    root.title("Skin Cancer Classification")
    root.geometry("800x600")
    show_welcome_screen()
    root.mainloop()

if __name__ == "__main__":
    main()
